#include "io.h"// #include "../utils.h"// #include "../config.h"  // #include "../mutex.h"// #include "../log.h"// #include "../apierror.h"// #include "../debug.h"#include "oss_c_sdk/aos_log.h"#include "oss_c_sdk/aos_util.h"#include "oss_c_sdk/aos_string.h"#include "oss_c_sdk/aos_status.h"#include "oss_c_sdk/oss_auth.h"#include "oss_c_sdk/oss_util.h"#include "oss_c_sdk/oss_api.h"#define JANUS_OSS_NAME  "JANUS OSS IO"#define JANUS_OSS_PACKAGE  "janus.io.oss"/* Useful stuff */static volatile int initialized = 0, stopping = 0;/* Static configuration instance */// static janus_config *config = NULL;// static const char *config_folder = NULL;// static janus_mutex config_mutex = JANUS_MUTEX_INITIALIZER;static char *endpoint = "oss-cn-shenzhen.aliyuncs.com";static char *access_key_id = "3vl2n2NNTv3HkQtI";static char *access_key_secret = "wN4X0k6Gx8pSs2PsJrNubYv3v1uIm9";static char *bucket = NULL;static char *prefix = NULL;typedef struct janus_oss {	aos_pool_t *pool;    oss_request_options_t *options;	char *endpoint;	oss_config_t *config;	aos_string_t bucket;	aos_string_t object;	int64_t position;} janus_oss;typedef struct janus_oss_message {	janus_io_info *handle;	char *transaction;	json_t *message;	json_t *jsep;} janus_oss_message;static int pares_oss_path(janus_oss *oss, const char *path);static int janus_oss_init(janus_oss *oss, const char *path);static void init_options(oss_request_options_t *options);static int janus_io_init(const char *config_path);static void janus_io_destroy(void);static int janus_io_get_api_compatibility(void);static int janus_oss_info_create(janus_io_info *info);static int janus_oss_close(janus_io_info *io_info);static int janus_io_write_data(janus_io_info *io_info, char *buf, size_t len);static int janus_io_read_data(janus_io_info *io_info, char *buf);static int janus_io_read_data_range(janus_io_info *io_info, char *buf, size_t start, size_t size);static int janus_read_data_to_file(janus_io_info *io_info, const char *filename);static int janus_io_write_data_sync(janus_io_info *io_info, char *buf, size_t len);static janus_io janus_oss_io =	JANUS_IO_INIT (		.init = janus_io_init,		.destroy = janus_io_destroy,		.get_api_compatibility = janus_io_get_api_compatibility,		.io_info_create = janus_oss_info_create,		.io_info_close = janus_oss_close,		.write_data = janus_io_write_data,		.read_data = janus_io_read_data,		.read_data_range = janus_io_read_data_range,		.read_data_to_file = janus_read_data_to_file,	);/* Transport creator */janus_io *create(void) {	// JANUS_LOG(LOG_VERB, "%s created!\n", JANUS_OSS_NAME);	return &janus_oss_io;}/* Transport implementation */static int janus_io_init(const char *config_path) {	if(g_atomic_int_get(&stopping)) {		/* Still stopping from before */		return -1;	}	if(config_path == NULL) {		/* Invalid arguments */		return -1;	}	if (aos_http_io_initialize(NULL, 0) != AOSE_OK) {        return -1;    }	/* Read configuration */	// char filename[255];	// g_snprintf(filename, 255, "%s/%s.cfg", config_path, JANUS_OSS_PACKAGE);	// JANUS_LOG(LOG_VERB, "Configuration file: %s\n", filename);	// config = janus_config_parse(filename);	// config_folder = config_path;	// if(config != NULL)	// 	janus_config_print(config);	// /* Parse configuration to populate the rooms list */	// if(config != NULL) {	// 	janus_config_item *key = janus_config_get_item_drilldown(config, "general", "endpoint");	// 	if(key != NULL && key->value != NULL)	// 		endpoint = g_strdup(key->value);	// 	janus_config_item *access_key_id_item = janus_config_get_item_drilldown(config, "general", "access_key_id");	// 	if(access_key_id_item != NULL && access_key_id_item->value != NULL)	// 		access_key_id = g_strdup(access_key_id_item->value);	// 	janus_config_item *access_key_secret_item = janus_config_get_item_drilldown(config, "general", "access_key_secret");	// 	if(access_key_secret_item != NULL && access_key_secret_item->value != NULL)	// 		access_key_secret = g_strdup(access_key_secret_item->value);	// 	janus_config_item *bucket_item = janus_config_get_item_drilldown(config, "general", "bucket");	// 	if(bucket_item != NULL && bucket_item->value != NULL)	// 		bucket = g_strdup(bucket_item->value);	// 	janus_config_item *prefix_item = janus_config_get_item_drilldown(config, "general", "prefix");	// 	if(prefix_item != NULL && prefix_item->value != NULL)	// 		prefix = g_strdup(prefix_item->value);			// 	/* Done: we keep the configuration file open in case we get a "create" or "destroy" with permanent=true */	// }	// JANUS_LOG(LOG_INFO, "%s initialized!\n", JANUS_OSS_NAME);	return 0;}static void janus_io_destroy(void) {	if(!g_atomic_int_get(&initialized))		return;	g_atomic_int_set(&stopping, 1);	// janus_config_destroy(config);	// g_free(endpoint);	// g_free(access_key_id);	// g_free(access_key_secret);	// g_free(bucket);	// g_free(prefix);aos_pool_destroy(p);    /* 释放全局资源，应该放在程序结束前 */    aos_http_io_deinitialize();	g_atomic_int_set(&initialized, 0);	g_atomic_int_set(&stopping, 0);	// JANUS_LOG(LOG_INFO, "%s destroyed!\n", JANUS_OSS_NAME);}static int janus_io_get_api_compatibility(void) {	/* Important! This is what your plugin MUST always return: don't lie here or bad things will happen */	return JANUS_IO_API_VERSION;}static void init_options(oss_request_options_t *options) {    options->config = oss_config_create(options->pool);    aos_str_set(&options->config->endpoint, endpoint);    aos_str_set(&options->config->access_key_id, access_key_id);    aos_str_set(&options->config->access_key_secret, access_key_secret);    options->config->is_cname = 0;    options->ctl = aos_http_controller_create(options->pool, 0);}static int pares_oss_path(janus_oss *oss, const char *path) {	aos_info_log("----------- pares_oss_path: %s -----------\n", path);	if (oss == NULL || path == NULL) {		aos_error_log("parse path error.");		return -1;	}	path = g_strdup(path);	char *p = strstr(path, "//");	if (p == NULL ) {		aos_error_log("parse path error.");		return  -1;	}	p = p + 2;	//解析出bucket name	char *tmp = strchr(p, '.');		if (tmp == NULL ) {		aos_error_log("parse path error.");		return  -1;	}	*tmp = '\0';	aos_info_log("bucket: %s\n", p);	aos_str_set(&oss->bucket, g_strdup(p));	*tmp = '.';	//解析出endpoint和object	p = tmp + 1;	tmp = strchr(p, '/');	if (tmp == NULL ) {		aos_error_log("parse path error.");		return  -1;	}	*tmp = '\0';	aos_info_log("endpoint: %s\n", p);	oss->endpoint = g_strdup(p);	aos_info_log("object: %s\n", tmp + 1);	aos_str_set(&oss->object, g_strdup(tmp + 1));	*tmp = '/';	g_free(path);	return 1;}int64_t janus_get_real_time(void) {	struct timespec ts;	clock_gettime (CLOCK_REALTIME, &ts);	return (ts.tv_sec*(int64_t)1000000) + (ts.tv_nsec/(int64_t)1000);}static int janus_oss_init(janus_oss *oss, const char *path) {	aos_info_log("----------- janus_oss_init -----------\n");	if (path != NULL) {		return pares_oss_path(oss, path);	} else {		aos_str_set(&oss->bucket, g_strdup(bucket));		oss->endpoint = g_strdup(endpoint);		int64_t now = janus_get_real_time();		char buffer[255];		g_snprintf(buffer, 255, "%s/oss-%"SCNi64"", prefix, now);		aos_str_set(&oss->object, g_strdup(buffer));	}	return 1;}static int janus_oss_info_create(janus_io_info *info) {	if (info == NULL || info->path == NULL) {		aos_error_log("----------- janus_oss_info_create arguments error. -----------\n");		return -1;	}	janus_oss *oss = g_malloc0(sizeof(janus_oss));	if (janus_oss_init(oss, info->path) < 0) {		aos_error_log("----------- janus_oss_init error -----------\n");		g_free(oss);		return -1;	}	aos_pool_create(&oss->pool, NULL);	oss->options = oss_request_options_create(oss->pool);	init_options(oss->options);	aos_str_set(&oss->options->config->endpoint, oss->endpoint);		info->io_handle = oss;	return 1;}static int janus_oss_close(janus_io_info *io_info) {	if (io_info == NULL || io_info->io_handle == NULL) {		aos_error_log("janus oss close error.");		return -1;	}	janus_oss *oss = io_info->io_handle;	if (oss->pool) {		aos_pool_destroy(oss->pool);	}	return 0;}static int janus_io_write_data(janus_io_info *io_info, char *buf, size_t len) {	if (io_info == NULL || io_info->io_handle == NULL) {		return -1;	}	janus_oss *oss = io_info->io_handle;    int64_t position = 0;    aos_status_t *s = NULL;    aos_table_t *headers1 = NULL;    aos_table_t *headers2 = NULL;    aos_table_t *resp_headers = NULL;    aos_list_t buffer;    aos_buf_t *content = NULL;    char *next_append_position = NULL;    char *object_type = NULL;    aos_info_log("acces key: (%s, %s)", oss->options->config->access_key_id.data, oss->options->config->access_key_secret.data);    s = oss_head_object(oss->options, &oss->bucket, &oss->object, headers1, &resp_headers);    if (aos_status_is_ok(s)) {        object_type = (char*)(apr_table_get(resp_headers, OSS_OBJECT_TYPE));        if (0 != strncmp(OSS_OBJECT_TYPE_APPENDABLE, object_type,                          strlen(OSS_OBJECT_TYPE_APPENDABLE)))         {            // printf("object[%s]'s type[%s] is not Appendable\n", OBJECT_NAME, object_type);            aos_pool_destroy(oss->pool);            return -1;        }        next_append_position = (char*)(apr_table_get(resp_headers, OSS_NEXT_APPEND_POSITION));        position = aos_atoi64(next_append_position);    }    headers2 = aos_table_make(oss->pool, 0);    aos_list_init(&buffer);    content = aos_buf_pack(oss->pool, buf, strlen(buf));    aos_list_add_tail(&content->node, &buffer);    s = oss_append_object_from_buffer(oss->options, &oss->bucket, &oss->object,             position, &buffer, headers2, &resp_headers);    if (aos_status_is_ok(s))    {        aos_info_log("append object from buffer succeeded\n");    } else {        aos_error_log("append object from buffer failed: %s, %s\n", s->error_code, s->error_msg);    }    return len;}static int janus_io_read_data(janus_io_info *io_info, char *buf) {	return -1;}static int janus_io_read_data_range(janus_io_info *io_info, char *buf, size_t start, size_t size) {	if (io_info == NULL || io_info->io_handle == NULL) {		return -1;	}	janus_oss *oss = io_info->io_handle;    aos_table_t *headers = NULL;    aos_table_t *params = NULL;    aos_table_t *resp_headers = NULL;    aos_status_t *s = NULL;    aos_list_t buffer;    aos_buf_t *content = NULL;    int64_t len = 0;    int64_t pos = 0;    aos_list_init(&buffer);    headers = aos_table_make(oss->pool, 1);    /* 设置Range，读取文件的指定范围，bytes=20-100包括第20和第100个字符 */    char range[255];    g_snprintf(range, 255, "bytes=%d-%d", start, start + size);    apr_table_set(headers, "Range", range);    s = oss_get_object_to_buffer(oss->options, &oss->bucket, &oss->object,                                  headers, params, &buffer, &resp_headers);    if (aos_status_is_ok(s)) {        aos_info_log("get object to buffer succeeded\n");    }    else {        aos_error_log("get object to buffer failed\n");      }    //get buffer len    aos_list_for_each_entry(aos_buf_t, content, &buffer, node) {        len += aos_buf_size(content);    }    buf[len] = '\0';    //copy buffer content to memory    aos_list_for_each_entry(aos_buf_t, content, &buffer, node) {        size = aos_buf_size(content);        memcpy(buf + pos, content->pos, (size_t)size);        pos += size;    }    return len;}static int janus_read_data_to_file(janus_io_info *io_info, const char *filename) {	if (io_info == NULL || io_info->io_handle == NULL) {		return -1;	}	janus_oss *oss = io_info->io_handle;    aos_table_t *headers = NULL;    aos_table_t *params = NULL;    aos_table_t *resp_headers = NULL;    aos_status_t *s = NULL;    aos_string_t file;    headers = aos_table_make(oss->pool, 0);    aos_str_set(&file, filename);    s = oss_get_object_to_file(oss->options, &oss->bucket, &oss->object, headers,                                params, &file, &resp_headers);    if (aos_status_is_ok(s)) {        aos_info_log("get object to local file succeeded: %d\n", s->code);    } else if(s->code == 404) {    	aos_info_log("oss no such object: (%d, %s, %s)\n", s->code, s->error_code, s->error_msg);    } else {        aos_error_log("get object to local file failed: (%d, %s, %s)\n", s->code, s->error_code, s->error_msg);        return -1;    }    return 0;}static int janus_io_write_data_sync(janus_io_info *io_info, char *buf, size_t len) {	return 0;}